# **LLM Implementation Brief: Type-Safe FastAPI Pattern With Enum-Based Method Routing, Single & Batch Execution**

**version**: v1.1.2
**created date**: 21 Nov 2025

## **Goal**

Implement a FastAPI service architecture that supports:

1. **High type safety** at runtime and static development time.
2. **A unified pattern for interactive (single) and batch execution** of methods.
3. **Clear separation of “functional areas”** (e.g., `admin`, `graph`, `graph_edits`) using enums.
4. **Strongly typed request/response objects**, convertible to and from JSON, via a custom type-safe layer that is *Pydantic-compatible* so FastAPI can operate normally.
5. **Deterministic, non-dynamic method routing** based entirely on predefined hard-coded enums, avoiding runtime surprises.

---

# **Core Architecture**

## **1. Functional Areas Defined via Enums**

Each major API “area” is represented by an enum, such as:

* `AdminArea`
* `GraphArea`
* `GraphEditArea`
* etc.

Each enum value corresponds to a **class** containing the actual implementation methods for that area.

This acts like a namespaced method registry.

### **Why?**

* Strong type safety
* Hard-coded, static mapping
* Batch executor can refer to these areas deterministically
* No dynamic dispatch that can cause runtime errors

---

## **2. Area Classes Containing Implementation Methods**

For each enum value, there is a class that defines the **actual handlers** for that area.

Example structure:

```python
class AdminMethods:
    @staticmethod
    def create_user(req: CreateUserRequest) -> CreateUserResponse: ...
```

These methods are used by:

* **Single (interactive) FastAPI endpoints**
* **Batch execution engine**

They should be static or class methods so they can be referenced without needing instantiation.

---

## **3. Custom “Type-Safe API” Layer With Pydantic Compatibility**

You have a custom type system that:

* Enforces strict runtime type validation
* Converts JSON → typed objects and typed objects → JSON
* Presents Pydantic-compatible classes, so FastAPI can treat them as if they are normal Pydantic models

This means:

* All request/response models are strongly typed
* FastAPI autogenerates schema from your layer
* Your internal logic gets strict type objects instead of raw dicts

---

## **4. Request/Response Classes Per Method**

Each method has a **pair** of classes:

* `MethodNameRequest`
* `MethodNameResponse`

These classes use your type-safe layer and are convertible to concrete JSON forms for FastAPI.

---

## **5. Single Execution Pattern (Standard FastAPI Endpoints)**

A single API endpoint is mapped **directly** to:

1. An **area enum**, e.g., `GraphArea.GRAPH_EDITS`
2. A **method enum**, e.g., `GraphEditMethods.ADD_NODE`
3. A **request model**
4. A call to the underlying static implementation method

This is hard-coded per route:

```python
@router.post("/addNode")
def add_node(req: AddNodeRequest):
    return GraphEditMethods.add_node(req)
```

This ensures:

* Zero runtime guessing
* Strong typing
* Consistent mapping between single and batch execution

---

## **6. Batch Execution Pattern**

Batch execution accepts a JSON structure that contains:

```json
{
  "area": "graph_edits",
  "method": "add_node",
  "payload": { ... }
}
```

Where:

* `area` is the string version of the functional-area enum
* `method` is the string version of that area’s method enum
* `payload` is a JSON object representing the request for that method

The batch executor then:

1. Converts `area` → enum → class
2. Converts `method` → enum → static method reference
3. Converts `payload` → request type
4. Invokes the method and returns response type → JSON

Since all enums and classes are predefined, this is still fully type-safe.

---

## **7. Benefits of This Approach**

* Unified method registry for both API routes and batch jobs
* Strong runtime validation
* Builds on Pydantic indirectly, but with additional type system guarantees
* Zero dynamic runtime behavior—everything is statically mapped
* Batch tasks can safely call any method that single endpoints can
* Allows comprehensive introspection, schema generation, and automated wiring

---

# **Deliverables to Implement**

When instructing an LLM, ask it to build:

1. **Enum definitions** for areas and methods
2. **Area classes** with static methods
3. **Typed request/response classes**
4. **The type-safe wrapper system** (Pydantic-compatible)
5. **Route generator for single execution**
6. **Batch execution dispatcher** that uses the enums + class/method mappings
7. Optional: automatic method registry for introspection

---

# **Implementation Constraints**

* No dynamic string-based lookups outside of enum resolution
* All method dispatch is static and hard-coded
* Batch mode must use the same method registry as single mode
* The type-safe layer must remain compatible with FastAPI’s expectations of Pydantic models

---

# **Example Prompt to Continue Implementation**

You can use this sentence to kick off coding work:

> “Please implement a FastAPI project following the architecture described above: enums defining functional areas, classes containing static methods, typed request/response classes using a custom type-safe Pydantic-compatible layer, single-execution routes, and a batch executor that dispatches using the enums and static method mappings.”