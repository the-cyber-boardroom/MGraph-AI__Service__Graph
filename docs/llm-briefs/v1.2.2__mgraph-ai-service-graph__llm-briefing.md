# MGraph-AI Service Graph: REST API Consumer Briefing

**Version**: v1.2.2  
**Last Updated**: 29th November 2025  
**Repository**: the-cyber-boardroom/MGraph-AI__Service__Graph

## Executive Summary

MGraph-AI Service Graph is a RESTful microservice that provides graph database operations backed by a distributed caching layer. It exposes the powerful MGraph-DB framework capabilities through a clean HTTP API, enabling graph creation, manipulation, querying, and export across multiple formats. The service is designed for type-safe operations with comprehensive schema validation and supports both individual operations and batch execution.

**Key Capabilities**:
- Create and manage typed graph structures
- Add nodes (basic, typed, value nodes) and edges (basic, typed, predicate-based)
- Query graphs by node/edge types with pagination
- Export graphs to JSON, DOT, Mermaid, and PNG formats
- Execute batched operations for complex workflows
- Automatic caching with namespace isolation

## Core Concepts

### The Graph Reference (`graph_ref`)

Every operation in the Graph Service uses a **graph reference** to identify which graph to operate on. This is the most important concept to understand:

```json
{
    "graph_ref": {
        "cache_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        "graph_id": "ab12cd34",
        "namespace": "my-project"
    }
}
```

| Field | Type | Description |
|-------|------|-------------|
| `cache_id` | UUID (Random_Guid) | Direct cache lookup key - most efficient |
| `graph_id` | 8-char hex (Obj_Id) | Internal graph identifier - requires hash lookup |
| `namespace` | String (Safe_Str__Id) | Isolation boundary for cache operations |

**Resolution Priority**:
1. If `cache_id` provided → Direct cache lookup (fastest)
2. If `graph_id` provided → Hash-based lookup to find `cache_id`
3. If neither provided → Creates a new empty graph

**Critical Rule**: After any write operation, always use the `graph_ref` from the response for subsequent operations. The service populates `cache_id` which is required for efficient lookups.

### Namespaces

Namespaces provide logical isolation for graphs:

```python
# Different projects can use separate namespaces
namespace = "my-app-production"
namespace = "my-app-staging"
namespace = "analytics-graphs"
```

Default namespace: `"graph-service"`

### Node Types

The service supports three main node patterns:

| Type | Description | Use Case |
|------|-------------|----------|
| **Basic Node** | Empty node with auto-generated ID | Graph structure, relationships |
| **Typed Node** | Node with specific type and data | Domain objects (Person, Document) |
| **Value Node** | Node storing a primitive value | Tags, labels, properties, deduplication |

**Value Node Uniqueness**: Value nodes with the same content automatically reference the same node. This provides built-in deduplication:

```python
# These operations return the SAME node_id
POST /graph-edit/add/value {"value": "python", "graph_ref": {...}}  # node_id: "abc123"
POST /graph-edit/add/value {"value": "python", "graph_ref": {...}}  # node_id: "abc123" (same!)
```

### Edge Types

| Type | Description | Use Case |
|------|-------------|----------|
| **Basic Edge** | Simple connection between nodes | Generic relationships |
| **Typed Edge** | Edge with specific type class | Domain relationships (OWNS, CONTAINS) |
| **Predicate Edge** | Semantic edge with predicate label | RDF-style relationships (has_name, works_at) |

## API Reference

### Base URL

```
Production: https://your-deployment.example.com
Local:      http://localhost:8000
```

### Authentication

The service uses header-based API key authentication (configured at deployment):

```http
X-API-Key: your-api-key-here
```

---

## CRUD Operations (`/graph-crud/`)

### Create Graph

Creates a new empty graph and optionally caches it.

```http
POST /graph-crud/create
Content-Type: application/json

{
    "graph_ref": {
        "namespace": "my-project"
    },
    "auto_cache": true
}
```

**Response**:
```json
{
    "graph_ref": {
        "cache_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        "graph_id": "ab12cd34",
        "namespace": "my-project"
    },
    "cached": true
}
```

### Get Graph

Retrieve a graph by reference.

```http
POST /graph-crud/get
Content-Type: application/json

{
    "graph_ref": {
        "cache_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        "namespace": "my-project"
    }
}
```

**Alternative URL-based lookups**:
```http
GET /graph-crud/get/by-cache-id/{cache_id}?namespace=my-project
GET /graph-crud/get/by-graph-id/{graph_id}?namespace=my-project
```

**Response**:
```json
{
    "graph_ref": {
        "cache_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        "graph_id": "ab12cd34",
        "namespace": "my-project"
    },
    "mgraph": {
        "nodes": {...},
        "edges": {...},
        "graph_data": {...}
    },
    "success": true
}
```

### Check Graph Exists

```http
POST /graph-crud/exists
Content-Type: application/json

{
    "cache_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "namespace": "my-project"
}
```

**Response**:
```json
{
    "graph_ref": {...},
    "exists": true
}
```

### Delete Graph

```http
POST /graph-crud/delete
Content-Type: application/json

{
    "cache_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "namespace": "my-project"
}
```

**Response**:
```json
{
    "graph_ref": {...},
    "deleted": true
}
```

---

## Edit Operations (`/graph-edit/`)

### Add Node (Basic)

Adds an empty node to the graph.

```http
POST /graph-edit/add/node
Content-Type: application/json

{
    "graph_ref": {
        "cache_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        "namespace": "my-project"
    },
    "auto_cache": true
}
```

**Response**:
```json
{
    "graph_ref": {
        "cache_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        "graph_id": "ab12cd34",
        "namespace": "my-project"
    },
    "node_id": "ef56gh78",
    "cached": true,
    "success": true
}
```

### Add Typed Node

Adds a node with a specific type and optional data.

```http
POST /graph-edit/add/node/typed
Content-Type: application/json

{
    "graph_ref": {
        "cache_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        "namespace": "my-project"
    },
    "node_type": "Schema__MGraph__Node",
    "node_data": {
        "custom_field": "value"
    },
    "auto_cache": true
}
```

### Add Value Node

Adds a node that stores a primitive value. **Automatically deduplicated**.

```http
POST /graph-edit/add/value
Content-Type: application/json

{
    "graph_ref": {
        "cache_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        "namespace": "my-project"
    },
    "value": "python",
    "key": "optional-unique-key",
    "auto_cache": true
}
```

**Response**:
```json
{
    "graph_ref": {...},
    "node_id": "ij90kl12",
    "value": "python",
    "cached": true,
    "success": true
}
```

### Get or Create Value Node

Returns existing value node if it exists, otherwise creates it.

```http
POST /graph-edit/add/value/get-or-create
Content-Type: application/json

{
    "graph_ref": {...},
    "value": "existing-tag",
    "auto_cache": true
}
```

### Add Edge (Basic)

Connects two nodes with a simple edge.

```http
POST /graph-edit/add/edge
Content-Type: application/json

{
    "graph_ref": {
        "cache_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        "namespace": "my-project"
    },
    "from_node_id": "ef56gh78",
    "to_node_id": "ij90kl12",
    "auto_cache": true
}
```

**Response**:
```json
{
    "graph_ref": {...},
    "edge_id": "mn34op56",
    "from_node_id": "ef56gh78",
    "to_node_id": "ij90kl12",
    "cached": true,
    "success": true
}
```

### Add Typed Edge

Adds an edge with a specific type.

```http
POST /graph-edit/add/edge/typed
Content-Type: application/json

{
    "graph_ref": {...},
    "from_node_id": "ef56gh78",
    "to_node_id": "ij90kl12",
    "edge_type": "Schema__MGraph__Edge",
    "auto_cache": true
}
```

### Add Predicate Edge

Adds a semantic edge with a predicate label (RDF-style).

```http
POST /graph-edit/add/edge/predicate
Content-Type: application/json

{
    "graph_ref": {...},
    "from_node_id": "ef56gh78",
    "to_node_id": "ij90kl12",
    "predicate": "has_tag",
    "auto_cache": true
}
```

### Delete Node

Removes a node and its connected edges.

```http
POST /graph-edit/delete/node
Content-Type: application/json

{
    "graph_ref": {...},
    "node_id": "ef56gh78"
}
```

**Response**:
```json
{
    "graph_ref": {...},
    "node_id": "ef56gh78",
    "deleted": true
}
```

### Delete Edge

```http
POST /graph-edit/delete/edge
Content-Type: application/json

{
    "graph_ref": {...},
    "edge_id": "mn34op56"
}
```

---

## Query Operations (`/graph-query/`)

### Find Nodes by Type

Finds all nodes of a specific type with pagination.

```http
POST /graph-query/find/nodes
Content-Type: application/json

{
    "graph_ref": {
        "cache_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        "namespace": "my-project"
    },
    "node_type": "Schema__MGraph__Node__Value",
    "limit": 100,
    "offset": 0
}
```

**Response**:
```json
{
    "graph_ref": {...},
    "node_ids": ["ef56gh78", "ij90kl12", "qr78st90"],
    "total_found": 3,
    "has_more": false
}
```

### Find Node by ID

Retrieves a specific node with its data.

```http
POST /graph-query/find/node
Content-Type: application/json

{
    "graph_ref": {...},
    "node_id": "ef56gh78"
}
```

**Response**:
```json
{
    "graph_ref": {...},
    "node_id": "ef56gh78",
    "node_data": {
        "node_type": "Schema__MGraph__Node__Value",
        "node_data": {
            "value": "python",
            "value_type": "str"
        }
    },
    "found": true
}
```

### Find Edges by Type

```http
POST /graph-query/find/edges
Content-Type: application/json

{
    "graph_ref": {...},
    "edge_type": "Schema__MGraph__Edge"
}
```

**Response**:
```json
{
    "graph_ref": {...},
    "edge_type": "Schema__MGraph__Edge",
    "edges": [
        {
            "edge_id": "mn34op56",
            "from_node_id": "ef56gh78",
            "to_node_id": "ij90kl12",
            "edge_type": "Schema__MGraph__Edge",
            "edge_data": {}
        }
    ],
    "total_found": 1
}
```

---

## Export Operations (`/graph-export/`)

### Export to JSON

```http
POST /graph-export/to-json
Content-Type: application/json

{
    "graph_ref": {...},
    "compressed": false,
    "pretty": true
}
```

**Response**:
```json
{
    "graph_ref": {...},
    "graph_json": {
        "nodes": {...},
        "edges": {...},
        "graph_data": {...}
    },
    "success": true
}
```

### Export to DOT (Graphviz)

```http
POST /graph-export/dot
Content-Type: application/json

{
    "graph_ref": {...},
    "include_node_ids": false,
    "include_edge_ids": false,
    "show_value_nodes": true
}
```

**Response**:
```json
{
    "graph_ref": {...},
    "dot": "digraph G {\n  node1 -> node2;\n  ...\n}",
    "success": true
}
```

### Export to Mermaid

```http
POST /graph-export/mermaid
Content-Type: application/json

{
    "graph_ref": {...},
    "include_node_ids": false,
    "direction": "TD"
}
```

**Response**:
```json
{
    "graph_ref": {...},
    "mermaid": "graph TD\n  A --> B\n  ...",
    "success": true
}
```

**Direction Options**: `TD` (top-down), `TB` (top-bottom), `BT` (bottom-top), `LR` (left-right), `RL` (right-left)

### Generate Screenshot (PNG)

```http
POST /graph-export/screenshot
Content-Type: application/json

{
    "graph_ref": {...},
    "width": 800,
    "height": 600,
    "include_node_ids": false,
    "show_value_nodes": true
}
```

**Response**:
```json
{
    "graph_ref": {...},
    "format": "png",
    "image_base64": "iVBORw0KGgoAAAANSUhEUgAA...",
    "content_type": "image/png",
    "success": true
}
```

### Get Screenshot as PNG Binary

```http
POST /graph-export/screenshot/png
Content-Type: application/json

{
    "graph_ref": {...}
}
```

**Response**: Raw PNG binary with `Content-Type: image/png`

---

## Batch Execution (`/graph/batch/`)

Execute multiple operations in sequence. Ideal for complex graph construction.

```http
POST /graph/batch/execute
Content-Type: application/json

{
    "commands": [
        {
            "area": "graph_crud",
            "method": "create_graph",
            "payload": {
                "namespace": "batch-test"
            }
        },
        {
            "area": "graph_edit",
            "method": "add_value",
            "payload": {
                "cache_id": "{{previous.cache_id}}",
                "namespace": "batch-test",
                "value": "root-node"
            }
        }
    ],
    "stop_on_error": true,
    "namespace": "batch-test"
}
```

**Response**:
```json
{
    "results": [
        {"cache_id": "...", "graph_id": "...", "cached": true},
        {"node_id": "...", "value": "root-node", "success": true}
    ],
    "total_commands": 2,
    "stop_on_error": true,
    "success": true,
    "successful": 2,
    "failed": 0,
    "errors": []
}
```

### Available Areas and Methods

| Area | Methods |
|------|---------|
| `graph_crud` | `create_graph`, `get_graph`, `delete_graph`, `graph_exists` |
| `graph_edit` | `add_node`, `add_typed_node`, `add_value`, `get_or_create_value`, `add_edge`, `add_typed_edge`, `add_predicate_edge`, `delete_node`, `delete_edge` |
| `graph_query` | `find_nodes_by_type`, `find_node_by_id`, `find_edges_by_type` |
| `graph_export` | `export_json`, `export_dot`, `export_mermaid`, `screenshot` |

---

## Server Information (`/graph/server/`)

### Get Server Configuration

```http
GET /graph/server/config
```

**Response**:
```json
{
    "graph_service__version": "v1.2.1",
    "cache_service__client__version": "v0.20.0",
    "cache_service__base_url": "https://cache.example.com",
    "cache_service__api_key_header": "X-API-Key",
    "cache_service__mode": "production"
}
```

---

## Common Patterns

### Pattern 1: Create Graph and Add Nodes

```python
import requests

BASE_URL = "https://your-service.example.com"
HEADERS = {"Content-Type": "application/json"}

# Step 1: Create graph
response = requests.post(f"{BASE_URL}/graph-crud/create", 
    json={"graph_ref": {"namespace": "my-app"}, "auto_cache": True},
    headers=HEADERS
)
graph_ref = response.json()["graph_ref"]

# Step 2: Add value nodes (tags)
for tag in ["python", "api", "graph"]:
    response = requests.post(f"{BASE_URL}/graph-edit/add/value",
        json={"graph_ref": graph_ref, "value": tag, "auto_cache": True},
        headers=HEADERS
    )
    graph_ref = response.json()["graph_ref"]  # Always update graph_ref!
```

### Pattern 2: Build Document with Properties

```python
# Create document node
doc_response = requests.post(f"{BASE_URL}/graph-edit/add/node",
    json={"graph_ref": graph_ref, "auto_cache": True},
    headers=HEADERS
)
doc_node_id = doc_response.json()["node_id"]
graph_ref = doc_response.json()["graph_ref"]

# Add properties as value nodes with predicate edges
properties = {"title": "My Document", "author": "John Doe", "status": "draft"}

for predicate, value in properties.items():
    # Create value node
    value_response = requests.post(f"{BASE_URL}/graph-edit/add/value",
        json={"graph_ref": graph_ref, "value": value, "auto_cache": True},
        headers=HEADERS
    )
    value_node_id = value_response.json()["node_id"]
    graph_ref = value_response.json()["graph_ref"]
    
    # Connect with predicate edge
    edge_response = requests.post(f"{BASE_URL}/graph-edit/add/edge/predicate",
        json={
            "graph_ref": graph_ref,
            "from_node_id": doc_node_id,
            "to_node_id": value_node_id,
            "predicate": predicate,
            "auto_cache": True
        },
        headers=HEADERS
    )
    graph_ref = edge_response.json()["graph_ref"]
```

### Pattern 3: Batch Operations for Efficiency

```python
# Build a graph in a single request
commands = [
    {"area": "graph_crud", "method": "create_graph", 
     "payload": {"namespace": "batch-demo"}},
    
    {"area": "graph_edit", "method": "add_value",
     "payload": {"value": "root", "namespace": "batch-demo"}},
    
    {"area": "graph_edit", "method": "add_value", 
     "payload": {"value": "child-1", "namespace": "batch-demo"}},
    
    {"area": "graph_edit", "method": "add_value",
     "payload": {"value": "child-2", "namespace": "batch-demo"}}
]

response = requests.post(f"{BASE_URL}/graph/batch/execute",
    json={"commands": commands, "stop_on_error": True, "namespace": "batch-demo"},
    headers=HEADERS
)
results = response.json()["results"]
```

### Pattern 4: Query and Export

```python
# Find all value nodes
query_response = requests.post(f"{BASE_URL}/graph-query/find/nodes",
    json={
        "graph_ref": graph_ref,
        "node_type": "Schema__MGraph__Node__Value",
        "limit": 100
    },
    headers=HEADERS
)
node_ids = query_response.json()["node_ids"]

# Export as Mermaid for documentation
mermaid_response = requests.post(f"{BASE_URL}/graph-export/mermaid",
    json={"graph_ref": graph_ref, "direction": "LR"},
    headers=HEADERS
)
mermaid_code = mermaid_response.json()["mermaid"]
print(mermaid_code)

# Generate PNG visualization
png_response = requests.post(f"{BASE_URL}/graph-export/screenshot/png",
    json={"graph_ref": graph_ref},
    headers=HEADERS
)
with open("graph.png", "wb") as f:
    f.write(png_response.content)
```

---

## Error Handling

### Error Response Format

All errors return a consistent JSON structure:

```json
{
    "error": "GRAPH_REF_NOT_FOUND",
    "message": "Graph not found for cache_id: invalid-id",
    "details": {
        "cache_id": "invalid-id",
        "namespace": "my-project"
    },
    "timestamp": 1732876543210
}
```

### Error Types

| Error Type | HTTP Status | Description |
|------------|-------------|-------------|
| `GRAPH_REF_NOT_FOUND` | 404 | Graph does not exist in cache |
| `GRAPH_REF_ERROR` | 400 | Invalid graph reference format |
| `GRAPH_SERVICE_ERROR` | 500 | Internal service error |

### Handling Errors in Code

```python
response = requests.post(f"{BASE_URL}/graph-crud/get",
    json={"graph_ref": {"cache_id": "invalid", "namespace": "test"}},
    headers=HEADERS
)

if response.status_code == 404:
    error = response.json()
    print(f"Graph not found: {error['message']}")
elif response.status_code == 200:
    data = response.json()
    if data.get("success"):
        graph = data["mgraph"]
    else:
        print("Graph retrieval failed")
```

---

## Best Practices

### 1. Always Propagate `graph_ref`

After any write operation, use the returned `graph_ref` for subsequent calls:

```python
# ✓ CORRECT - Use returned graph_ref
response1 = add_node(graph_ref)
graph_ref = response1["graph_ref"]  # Update!

response2 = add_node(graph_ref)     # Use updated ref
graph_ref = response2["graph_ref"]  # Update again!

# ✗ WRONG - Reusing stale graph_ref
response1 = add_node(original_ref)
response2 = add_node(original_ref)  # May cause issues!
```

### 2. Use Namespaces for Isolation

```python
# ✓ CORRECT - Separate namespaces for environments
production_ref = {"namespace": "myapp-prod"}
staging_ref = {"namespace": "myapp-staging"}
test_ref = {"namespace": "myapp-test"}

# ✗ WRONG - Everything in default namespace
ref = {"namespace": "graph-service"}  # Collisions likely
```

### 3. Leverage Value Node Deduplication

```python
# ✓ CORRECT - Let the service handle deduplication
tag1 = add_value("python")  # Creates node
tag2 = add_value("python")  # Returns same node!

# ✗ WRONG - Manual deduplication
existing = find_value("python")
if not existing:
    tag = add_value("python")
```

### 4. Use Batch for Complex Operations

```python
# ✓ CORRECT - Single request for multiple operations
batch_execute([
    create_graph(...),
    add_node(...),
    add_node(...),
    add_edge(...),
    add_edge(...)
])

# ✗ WRONG - Multiple round trips
create_graph(...)
add_node(...)
add_node(...)
add_edge(...)
add_edge(...)
```

### 5. Use Predicates for Semantic Relationships

```python
# ✓ CORRECT - Clear semantic meaning
add_predicate_edge(person_id, name_id, predicate="has_name")
add_predicate_edge(person_id, company_id, predicate="works_at")

# ✗ WRONG - Generic edges lose meaning
add_edge(person_id, name_id)
add_edge(person_id, company_id)
```

### 6. Handle Pagination for Large Graphs

```python
# ✓ CORRECT - Paginate through results
all_nodes = []
offset = 0
limit = 100

while True:
    response = find_nodes(node_type="MyType", limit=limit, offset=offset)
    all_nodes.extend(response["node_ids"])
    
    if not response["has_more"]:
        break
    offset += limit

# ✗ WRONG - Assuming all results returned
response = find_nodes(node_type="MyType")  # Only first 100!
```

---

## Type Reference

### Core Identifier Types

| Type | Format | Example |
|------|--------|---------|
| `Cache_Id` | UUID v4 | `"a1b2c3d4-e5f6-7890-abcd-ef1234567890"` |
| `Graph_Id` | 8-char hex (Obj_Id) | `"ab12cd34"` |
| `Node_Id` | 8-char hex (Obj_Id) | `"ef56gh78"` |
| `Edge_Id` | 8-char hex (Obj_Id) | `"mn34op56"` |
| `Safe_Str__Id` | Alphanumeric + `-_` | `"my-namespace"` |

### Schema Types (for typed nodes/edges)

| Type | Description |
|------|-------------|
| `Schema__MGraph__Node` | Base node type |
| `Schema__MGraph__Node__Value` | Value-storing node |
| `Schema__MGraph__Edge` | Base edge type |

---

## API Endpoints Summary

| Method | Path | Description |
|--------|------|-------------|
| `POST` | `/graph-crud/create` | Create new graph |
| `POST` | `/graph-crud/get` | Get graph by reference |
| `GET` | `/graph-crud/get/by-cache-id/{id}` | Get graph by cache_id |
| `GET` | `/graph-crud/get/by-graph-id/{id}` | Get graph by graph_id |
| `POST` | `/graph-crud/exists` | Check if graph exists |
| `POST` | `/graph-crud/delete` | Delete graph |
| `POST` | `/graph-edit/add/node` | Add basic node |
| `POST` | `/graph-edit/add/node/typed` | Add typed node |
| `POST` | `/graph-edit/add/value` | Add value node |
| `POST` | `/graph-edit/add/value/get-or-create` | Get or create value node |
| `POST` | `/graph-edit/add/edge` | Add basic edge |
| `POST` | `/graph-edit/add/edge/typed` | Add typed edge |
| `POST` | `/graph-edit/add/edge/predicate` | Add predicate edge |
| `POST` | `/graph-edit/delete/node` | Delete node |
| `POST` | `/graph-edit/delete/edge` | Delete edge |
| `POST` | `/graph-query/find/nodes` | Find nodes by type |
| `POST` | `/graph-query/find/node` | Find node by ID |
| `POST` | `/graph-query/find/edges` | Find edges by type |
| `POST` | `/graph-export/to-json` | Export to JSON |
| `POST` | `/graph-export/dot` | Export to DOT |
| `POST` | `/graph-export/mermaid` | Export to Mermaid |
| `POST` | `/graph-export/screenshot` | Generate screenshot (base64) |
| `POST` | `/graph-export/screenshot/png` | Generate screenshot (binary) |
| `POST` | `/graph/batch/execute` | Execute batch commands |
| `GET` | `/graph/server/config` | Get server configuration |

---

## Integration with MGraph-DB

This service wraps the MGraph-DB library. Key mappings:

| Service Operation | MGraph-DB Equivalent |
|-------------------|---------------------|
| `add/node` | `mgraph.edit().new_node()` |
| `add/value` | `mgraph.edit().new_value()` |
| `add/edge/predicate` | `mgraph.edit().get_or_create_edge(predicate=...)` |
| `find/nodes` | `mgraph.index().nodes_by_type()` |
| `export/dot` | `mgraph.export().to__dot()` |
| `screenshot` | `mgraph.screenshot().dot()` |

For advanced operations not yet exposed via REST, consider using MGraph-DB directly in Python.

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| v1.2.1 | 2025-11-29 | Current stable release |
| v1.2.0 | 2025-11-28 | Added batch execution, export improvements |
| v1.1.0 | 2025-11-25 | Added predicate edges, query pagination |
| v1.0.0 | 2025-11-20 | Initial release |

---

## Dependencies

- **MGraph-DB**: v1.3.0+ (graph database framework)
- **MGraph-AI-Service-Cache-Client**: v0.20.0+ (caching layer)
- **OSBot-Fast-API-Serverless**: v1.29.0+ (API framework)

---

## Support

- **Documentation**: https://docs.mgraph.ai/service-graph
- **Issues**: https://github.com/the-cyber-boardroom/MGraph-AI__Service__Graph/issues
- **API Status**: https://status.mgraph.ai
